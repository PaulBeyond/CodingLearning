# BOOK_1_C与指针

## CHAPTER_1_上手

​	空白、注释、制表符 -> 提升代码可读性，便于后续修改

​	若有一份声明需要运用到不同的源文件中，可以include第一个头文件，而后在需要用到的源文件中声明一份拷贝，而用不着在许多不同的地方进行复制，避免维护时出现错误。

​	宏定义：字符串常量；函数原型的声明；main函数。

​	C语言中不存在string类型，字符串终止符为NUL，且终止符不看作是字符串的一部分，字符串常量就是用双引号括起来的一串字符。

​	格式化字符输出：%d %o %x ： 二进制、八进制、十六进制。

## CHAPTER_2_基本概念

翻译环境：源代码被转化成为可执行的机器指令；

执行环境：实际执行代码；

两种环境不必位于同一台机器上，例如交叉编译器；

独立环境是指不存在操作系统的环境，一般在嵌入式系统中遇到该类环境

### 翻译过程：

1. 预处理器处理：该阶段预处理器在源代码上执行一些文本操作，例如以实际值代替宏定义指令符号，读入include指令中包含的文件内容
2. 解析阶段：判断语句的意思，该阶段是产生绝大多数error和warning信息的地方，而后产生目标代码。目标代码是机器指令的初步形式，用于实现程序的语言。同时，在该阶段若存在需要进行优化的选项，优化器会对目标代码进一步进行处理，提高效率。

### 执行过程

1. 程序必须载入到内存中；
2. 程序执行开始，通常一个小型的启动程序与程序链接在一起，而后调用main函数；
3. 开始执行程序代码，运行堆栈stack以存储函数的局部变量和返回地址，同时程序也可以使用静态内存，存储于静态内存中的变量在程序的整个执行过程中将一直保留它们的值。
4. 程序终止。

### 词法规则

注释不能嵌套，编译时会被预处理器拿掉，取而代之的是一个空格。

### 代码风格

1. 空行用于分割不同的逻辑代码块，按功能分段；
2. 绝大多数操作符的使用，中间都隔以空格，以增强可读性；
3. 嵌套于其他语句的语句使用缩进，以显示他们之间的层次；
4. 注释成块出现

## CHAPTER_3_数据

1. 整型：有符号、无符号，长整型
2. ......
3. 指针：
   1. 指针常量
   2. 字符串常量

typedef：为各种数据类型定义新的名字

const：申明常量不能修改

1. 指向整型常量的指针：可以修改指针的值，但不能修改所指向的值
2. 指向整型的常量指针：指针是常量，但可以修改所指向的整型的值

```C++
int const * pci; // 1. 指向整型常量的指针
int * const cpi; // 2. 指向整型的常量指针
int const * const cpci; // 指针和指向都是常量，不能更改
```

const和define相比，define更好，因为只要允许使用字面值常量的地方都可使用define，而const常量只能用于允许使用变量的地方。

```C++
#define MAX_ELEMENTS 50
int const max_elements = 50;
```

4. 在代码块之外声明的变量总是存储于静态内存中的，不属于堆栈内存，称为静态变量；
5. 代码块内部声明的变量存储于堆栈中，如果加上关键词static，则可以使他的存储类型从auto变为static，具有静态存储类型的变量在整个程序执行过程中一直存在

## CHAPTER_4_语句

空语句：本身只包含一个分号；

表达式语句：

常用语句与C++相同

## CHAPTER_5_操作符和表达式

移位操作符：简单地把一个值的位向左或者向右移动

1. 在左移位中，值最左边的几位被丢弃，右边多出来的几个空位由0补齐
2. 右移位操作
   1. 逻辑移位，左边移入的位用0填充
   2. 算术移位：左边移入的位由原先该值的符号决定，即符号位为1则移入位均为1；
3. 移位操作需要为整型，对于有符号值，采取逻辑移位还是算术移位取决于编译器

位操作符对它们的操作数各个位执行AND、OR和XOR等逻辑操作（&、|、^）；

关系操作符的返回值是整型，符合则为1，否则为0；（C语言中）

条件操作符：exp1 ? exp2 : exp3

逗号操作符，整个逗号表达式的值就是最后那个表达式的值

左值就是能够出现在赋值符号左边的东西，右值就是那些可以出现在赋值符号右边的东西：

1. 左值可以充当右值，右值不一定可以充当左值

表达式求值：

1. 隐式类型转化
2. 算术转换

操作符的属性：优先级、结合性、执行顺序；

## CHAPTER_6_指针

字节：每个字节包含8个位，可以存储无符号值(0~255)或有符号值(-128~127)

字：为了存储更大的值，通常把两个或者更多个字节合在一起作为一个更大的内存单元，许多机器以字为单元存储整数，每个字一般包含2个或者4个字节。

关心的主要问题：

1. 内存中每个位置由一个独一无二的地址标识
2. 内存中的每个位置都包含一个值

值的类型并非值本身所固有的一种特性，而是取决于它使用的方式。

指针自身的值为一个地址值，而需要使用间接访问操作符来获取其所指向的值

NULL指针：表示不指向任何东西，亦可对指针变量赋零值实现

```c++
*&a = 25;
```

指针的指针：*操作符具有从右向左的结合性

指针表达式

## CHAPTER_7_函数

返回类型+函数名(形式参数)+代码块

## CHAPTER_8_数组

数组名的值是一个指针常量，指向数组第一个元素的地址。

正确使用的指针比下标更有效率，指针和数组并不是相等的

初始化与不完整初始化

### 多维数组

```c++
int (*p)[10]; // p为指向整型数组的指针
int matrix[3][10];
int (*p)[10] = matrix; // p指向matrix的第一行
int *pi = & matrix[0][0]; // pi 指向matrix的第一个整型元素
int *pi = matrix[0]; // 同上
```

当多维数组作为函数参数进行传递时：

```c++
// 一维
int vector[10];
void func1(int * vec);
void func2(int vec[]);
// 二维
int matrix[3][10];
void func3(int (*mat)[10]);
void func4(int mat[][10]);
```

指针数组：

```c++
int * pi[10];
```

## CHAPTER_9_字符串、字符和字节

## CHAPTER_10_结构和联合

struct：结构的声明与初始化，可以将结构看做最简单的类；

union：联合的所有成员引用的是内存中的相同位置

## CHAPTER_11_动态内存分配

malloc 可以从内存池中提取一块适合的内存，并向该程序返回一个指向这块内存的指针

free：当以前分配的内存不再使用时，程序调用free函数将它归还给内存池供以后之需；

```c++
include "stdlib.h"
void * malloc(size_t size);
void free(void *pointer);
```

​	malloc() 的参数为所需要的分配的内存字节数或者字符数，若可用内存满足需求，则返回一个指向被分配的内存块起始位置的指针：**连续内存！实际分配的内存可能比请求的稍多！**若可用内存不能满足需求，则返回NULL指针。

​	free()的参数要么为NULL，要么是先前从malloc、calloc或者realloc中创建出来的。

​	malloc()并不知道所请求内存需要存储的数据类型！！

```c++
void * calloc(size_t num_elements, size_t element_size);
void realloc(void *ptr, size_t new_size);
```

calloc与malloc相比在返回指向内存的指针之前将它初始化为0

realloc用于修改一个原先已经分配的内存块大小：

1. 扩大，则原先内容依旧保留，新增加的内存添加到原先内存块的后面；
2. 缩小：该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依旧保留；
3. 若原来内存块无法改变大小，realloc将分配到另一块大小正确的内存，并完成相应的复制操作；
4. 若realloc第一个参数为NULL，则与malloc一模一样。

```c++
int * pi;
pi = malloc(25 * sizeof(int));
```

动态内存的常见错误：

1. 对NULL指针进行解引用操作；
2. 对分配的内存进行操作时越过边界；
3. 释放非动态分配的内存；
4. 试图释放一块动态分配的内存的一部分；
5. 一块动态内存被释放后继续使用；
6. 动态分配的内存不再使用时，没有及时释放。

## CHAPTER_12_使用结构和指针

构建链表：单链表、双链表

## CHAPTER_13_高级指针话题(Page 278)

多层间接访问

```c++
int ***pi;
int (*f) ();
```

函数调用操作符的优先级高于间接访问操作符

下标操作符的优先级高于间接访问操作符

函数指针！

```c++
int f(int);
int (*pf)(int) = & f; // 创建函数指针pf指向f
int ans = f(25);
int ans = (*pf)(25);
int ans = pf(25); // 间接访问操作非必须
```

传递命令行参数

```c++
int main(int argc, char ** argv)
```

处理命令行参数

## CHAPTER_14_预处理器

```C++
_FILE_ // 进行编译的源文件名称
_LINE_ // 文件当前的行号
_DATE_ // 文件被编译的日期
_TIME_ // 文件被编译的时间
_STDC_ // 如果编译遵循ANSI_C，其值为1，否则未定义
#define name stuff // 	宏定义(defined macro)
#undef name // 移出一个宏定义
```

条件编译

```c++
#if constant-expression
#elif
#else
#endif
```

是否被定义

```C++
#ifndef
#if defined()
#ifdef
#id !defined()
```

## CHAPTER_15_输入输出函数

## CHAPTER_16_标准函数库

## CHAPTER_17_经典抽象数据类型

内存分配：

1. 静态数组：结构长度固定，编译时即确定，不容易出错
2. 动态数组：灵活性与复杂性的权衡取舍
3. 链式结构：最大程度上的灵活性，每个元素在需要的时候才单独进行分配，几乎没有数量限制，但是访问特定元素的效率不如数组

堆栈(stack)：后进先出

1. 堆栈接口：pop(将栈顶元素移出，不返回)，push，top(返回栈顶元素，不移出)
2. 实现堆栈：

队列(Queue)：先进先出

树(Tree):

## CHAPTER_18_运行时环境

