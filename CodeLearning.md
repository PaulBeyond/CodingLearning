[TOC]

# BOOK_1_C与指针

## CHAPTER_1_上手

​	空白、注释、制表符 -> 提升代码可读性，便于后续修改

​	若有一份声明需要运用到不同的源文件中，可以include第一个头文件，而后在需要用到的源文件中声明一份拷贝，而用不着在许多不同的地方进行复制，避免维护时出现错误。

​	宏定义：字符串常量；函数原型的声明；main函数。

​	C语言中不存在string类型，字符串终止符为NUL，且终止符不看作是字符串的一部分，字符串常量就是用双引号括起来的一串字符。

​	格式化字符输出：%d %o %x ： 二进制、八进制、十六进制。

## CHAPTER_2_基本概念

翻译环境：源代码被转化成为可执行的机器指令；

执行环境：实际执行代码；

两种环境不必位于同一台机器上，例如交叉编译器；

独立环境是指不存在操作系统的环境，一般在嵌入式系统中遇到该类环境

### 翻译过程：

1. 预处理器处理：该阶段预处理器在源代码上执行一些文本操作，例如以实际值代替宏定义指令符号，读入include指令中包含的文件内容
2. 解析阶段：判断语句的意思，该阶段是产生绝大多数error和warning信息的地方，而后产生目标代码。目标代码是机器指令的初步形式，用于实现程序的语言。同时，在该阶段若存在需要进行优化的选项，优化器会对目标代码进一步进行处理，提高效率。

### 执行过程

1. 程序必须载入到内存中；
2. 程序执行开始，通常一个小型的启动程序与程序链接在一起，而后调用main函数；
3. 开始执行程序代码，运行堆栈stack以存储函数的局部变量和返回地址，同时程序也可以使用静态内存，存储于静态内存中的变量在程序的整个执行过程中将一直保留它们的值。
4. 程序终止。

### 词法规则

注释不能嵌套，编译时会被预处理器拿掉，取而代之的是一个空格。

### 代码风格

1. 空行用于分割不同的逻辑代码块，按功能分段；
2. 绝大多数操作符的使用，中间都隔以空格，以增强可读性；
3. 嵌套于其他语句的语句使用缩进，以显示他们之间的层次；
4. 注释成块出现

## CHAPTER_3_数据

1. 整型：有符号、无符号，长整型
2. ......
3. 指针：
   1. 指针常量
   2. 字符串常量

typedef：为各种数据类型定义新的名字

const：申明常量不能修改

1. 指向整型常量的指针：可以修改指针的值，但不能修改所指向的值
2. 指向整型的常量指针：指针是常量，但可以修改所指向的整型的值

```C++
int const * pci; // 1. 指向整型常量的指针
int * const cpi; // 2. 指向整型的常量指针
int const * const cpci; // 指针和指向都是常量，不能更改
```

const和define相比，define更好，因为只要允许使用字面值常量的地方都可使用define，而const常量只能用于允许使用变量的地方。

```C++
#define MAX_ELEMENTS 50
int const max_elements = 50;
```

4. 在代码块之外声明的变量总是存储于静态内存中的，不属于堆栈内存，称为静态变量；
5. 代码块内部声明的变量存储于堆栈中，如果加上关键词static，则可以使他的存储类型从auto变为static，具有静态存储类型的变量在整个程序执行过程中一直存在

## CHAPTER_4_语句

空语句：本身只包含一个分号；

表达式语句：

常用语句与C++相同

## CHAPTER_5_操作符和表达式

移位操作符：简单地把一个值的位向左或者向右移动

1. 在左移位中，值最左边的几位被丢弃，右边多出来的几个空位由0补齐
2. 右移位操作
   1. 逻辑移位，左边移入的位用0填充
   2. 算术移位：左边移入的位由原先该值的符号决定，即符号位为1则移入位均为1；
3. 移位操作需要为整型，对于有符号值，采取逻辑移位还是算术移位取决于编译器

位操作符对它们的操作数各个位执行AND、OR和XOR等逻辑操作（&、|、^）；

关系操作符的返回值是整型，符合则为1，否则为0；（C语言中）

条件操作符：exp1 ? exp2 : exp3

逗号操作符，整个逗号表达式的值就是最后那个表达式的值

左值就是能够出现在赋值符号左边的东西，右值就是那些可以出现在赋值符号右边的东西：

1. 左值可以充当右值，右值不一定可以充当左值

表达式求值：

1. 隐式类型转化
2. 算术转换

操作符的属性：优先级、结合性、执行顺序；

## CHAPTER_6_指针

字节：每个字节包含8个位，可以存储无符号值(0~255)或有符号值(-128~127)

字：为了存储更大的值，通常把两个或者更多个字节合在一起作为一个更大的内存单元，许多机器以字为单元存储整数，每个字一般包含2个或者4个字节。

关心的主要问题：

1. 内存中每个位置由一个独一无二的地址标识
2. 内存中的每个位置都包含一个值

值的类型并非值本身所固有的一种特性，而是取决于它使用的方式。

指针自身的值为一个地址值，而需要使用间接访问操作符来获取其所指向的值

NULL指针：表示不指向任何东西，亦可对指针变量赋零值实现

```c++
*&a = 25;
```

指针的指针：*操作符具有从右向左的结合性

指针表达式

## CHAPTER_7_函数

返回类型+函数名(形式参数)+代码块

## CHAPTER_8_数组

数组名的值是一个指针常量，指向数组第一个元素的地址。

正确使用的指针比下标更有效率，指针和数组并不是相等的

初始化与不完整初始化

### 多维数组

```c++
int (*p)[10]; // p为指向整型数组的指针
int matrix[3][10];
int (*p)[10] = matrix; // p指向matrix的第一行
int *pi = & matrix[0][0]; // pi 指向matrix的第一个整型元素
int *pi = matrix[0]; // 同上
```

当多维数组作为函数参数进行传递时：

```c++
// 一维
int vector[10];
void func1(int * vec);
void func2(int vec[]);
// 二维
int matrix[3][10];
void func3(int (*mat)[10]);
void func4(int mat[][10]);
```

指针数组：

```c++
int * pi[10];
```

## CHAPTER_9_字符串、字符和字节

## CHAPTER_10_结构和联合

struct：结构的声明与初始化，可以将结构看做最简单的类；

union：联合的所有成员引用的是内存中的相同位置

## CHAPTER_11_动态内存分配

malloc 可以从内存池中提取一块适合的内存，并向该程序返回一个指向这块内存的指针

free：当以前分配的内存不再使用时，程序调用free函数将它归还给内存池供以后之需；

```c++
include "stdlib.h"
void * malloc(size_t size);
void free(void *pointer);
```

​	malloc() 的参数为所需要的分配的内存字节数或者字符数，若可用内存满足需求，则返回一个指向被分配的内存块起始位置的指针：**连续内存！实际分配的内存可能比请求的稍多！**若可用内存不能满足需求，则返回NULL指针。

​	free()的参数要么为NULL，要么是先前从malloc、calloc或者realloc中创建出来的。

​	malloc()并不知道所请求内存需要存储的数据类型！！

```c++
void * calloc(size_t num_elements, size_t element_size);
void realloc(void *ptr, size_t new_size);
```

calloc与malloc相比在返回指向内存的指针之前将它初始化为0

realloc用于修改一个原先已经分配的内存块大小：

1. 扩大，则原先内容依旧保留，新增加的内存添加到原先内存块的后面；
2. 缩小：该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依旧保留；
3. 若原来内存块无法改变大小，realloc将分配到另一块大小正确的内存，并完成相应的复制操作；
4. 若realloc第一个参数为NULL，则与malloc一模一样。

```c++
int * pi;
pi = malloc(25 * sizeof(int));
```

动态内存的常见错误：

1. 对NULL指针进行解引用操作；
2. 对分配的内存进行操作时越过边界；
3. 释放非动态分配的内存；
4. 试图释放一块动态分配的内存的一部分；
5. 一块动态内存被释放后继续使用；
6. 动态分配的内存不再使用时，没有及时释放。

## CHAPTER_12_使用结构和指针

构建链表：单链表、双链表

## CHAPTER_13_高级指针话题(Page 278)

多层间接访问

```c++
int ***pi;
int (*f) ();
```

函数调用操作符的优先级高于间接访问操作符

下标操作符的优先级高于间接访问操作符

函数指针！

```c++
int f(int);
int (*pf)(int) = & f; // 创建函数指针pf指向f
int ans = f(25);
int ans = (*pf)(25);
int ans = pf(25); // 间接访问操作非必须
```

传递命令行参数

```c++
int main(int argc, char ** argv)
```

处理命令行参数

## CHAPTER_14_预处理器

```C++
_FILE_ // 进行编译的源文件名称
_LINE_ // 文件当前的行号
_DATE_ // 文件被编译的日期
_TIME_ // 文件被编译的时间
_STDC_ // 如果编译遵循ANSI_C，其值为1，否则未定义
#define name stuff // 	宏定义(defined macro)
#undef name // 移出一个宏定义
```

条件编译

```c++
#if constant-expression
#elif
#else
#endif
```

是否被定义

```C++
#ifndef
#if defined()
#ifdef
#id !defined()
```

## CHAPTER_15_输入输出函数

## CHAPTER_16_标准函数库

## CHAPTER_17_经典抽象数据类型

内存分配：

1. 静态数组：结构长度固定，编译时即确定，不容易出错
2. 动态数组：灵活性与复杂性的权衡取舍
3. 链式结构：最大程度上的灵活性，每个元素在需要的时候才单独进行分配，几乎没有数量限制，但是访问特定元素的效率不如数组

堆栈(stack)：后进先出

1. 堆栈接口：pop(将栈顶元素移出，不返回)，push，top(返回栈顶元素，不移出)
2. 实现堆栈：

队列(Queue)：先进先出

树(Tree):

## CHAPTER_18_运行时环境



# BOOK_2_C++_Primer_Plus

## CHAPTER_0_前言

现代C++语言组成部分：低级语言(继承自C语言)、现代高级语言特性、标准库。

## CHAPTER_1_开始

编译命令

初始输入输出：

1. cin 和 cout
2. cerr：输出警告和错误信息，称作标准错误
3. clog：用于输出程序运行的一般性信息

标准库定义的所有名字都在命名空间`std`中，可以通过使用作用域运算符(::)来指出想使用定义在命名空间的名字

注释界定符不能嵌套

### 读取数量不定的输入数据

```c++
#include <iostream>
int main()
{
	int sum = 0, value = 0;
	while(std::cin >> value)
    /*
    * 若流是有效的，则检测成功，若遇到无效输入或者遇到文件结束符(end-of-file)，则返回False结束循环
    */
		sum += value;
	std::cout << "Sum is: " << sum << std::endl;
	return 0;
}
```

Tips：Win系统中输入文件结束符的方法是Ctrl + Z，然后Enter或者Return；在Unix或者macOS中，用Ctrl+D。

### 类简介

通过定义一个类(class)来定义自己的数据结构

## CHAPTER_2_变量和基本类型

算数类型(arithmetic type，包括字符、整型数、布尔值和浮点数)和空类型(void)

### 算术类型

算数类型分为两类

1. 整型：integral type，包括字符和布尔类型在内；
2. 浮点型

算术类型所占的比特数在不同机器上有所差别，C++标准规定的尺寸最小值为：

![image-20220901001919744](C:\Users\Hongji-Li\AppData\Roaming\Typora\typora-user-images\image-20220901001919744.png)

bool类型的取值是`TRUE`或者`False`

```c++
bool flag = (bool) 1; // warning c-cast
bool flag = bool(1); // right
bool flag = 1; // right 隐式转换
```

当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数

```c++
unsigned char c = -1; // 假设char占8比特，表征0-255，则对256取模，c=255
```

但当我们赋给带符号类型一个超出它表示范围的值，结果是未定义的，此时程序可能继续工作、崩溃，或者产生垃圾数据

```c++
unsigned char c1 = 266;
```

### 变量

变量定义：

对象：指一块能存储数据并具有某种类型的内存空间

初始值与初始化，以下四种等价

```c++
int k = 0;
int k = {0};
int k(0);
int k{0};
```

若使用列表初始化且初始化值存在丢失信息的风险，则编译器会报错：

```c++
long double ld = 3.1415;
int a{ld}, b = {ld}; // error
int c(ld), d = ld; // right, Some values are discarded
```

变量声明与定义：

1. 分离式编译机制的存在，允许将程序分割成若干个文件，并可被独立编译
2. 声明：使得名字为程序所知，规定了变量的类型和名字
3. 定义：创建与名字关联的实体，申请存储空间

```c++
extern int i; // declaration
int j; // define
```

4. 任何包含了显示初始化的声明即成为定义。
5. 变量只能被定义一次，但可以被多次声明，因此需要避免重复定义

### 复合类型

引用：即别名，必须初始化，允许在一条语句中定义多个引用，但必须都以&开头

指针：与引用类似，区别如下：

1. 指针本身也是一个对象，允许对其赋值与拷贝
2. 指针的生命周期内可以先后指向几个不同的对象
3. 指针无须在定义时赋值，若没有初始化，将拥有一个不确定的值

void* 指针是一种特殊的指针类型，可以用于存储任意对象的地址，一个void*指针存在着一个地址

### const 限定符

const对象一旦创建后其值就不能再改变了，故必须进行初始化

const变量仅在文件内有效，当多个文件中出现同名的const变量时，其实等同于在不同文件中分别定义了独立的变量

若需要在别的文件使用，则需要在定义和声明都添加extern关键字，这样就只需要定义一次就好了

const的引用->对常量的引用：对常量的引用不能被用作修改它所绑定的对象

指向常量的指针：不能用于改变其所指对象的值

常量指针必须初始化

#### 顶层const：

1. 指针本身是一个对象，它又可以指向另一个对象，因此指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题
2. 名词顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量：

```c++
int i = 0;
int * const p1 = & i; // 不能改变p1的值，这是一个顶层const
const int ci =42; // 不能改变c1的值，这是一个顶层const
const int * p2 = &ci; // 允许改变p2的值，这是一个底层const
const int * const p3 = p2; // 靠右的const是顶层const，靠左的是底层const
const int & r = ci; //用于声明引用的const都是底层const
```

3. 当执行对象的拷贝操作时，常量是顶层const或者底层const区别明显，其中，顶层const不受声明影响，执行拷贝操作并不会改变被拷贝对象的值；
4. 当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换成常量，反之则不行：

```c++
int * p = p3; // error, p3包含底层const的定义，而p没有
p2 = p3; // right
p2 = & i; // right, int * -> const int *
int & r = ci; // error, int & 不能绑定在int常量上
const int & r2 = i; // right, const int & 可以绑定到一个普通的int上
```

#### constexpr和常量表达式

常量表达式是指值不会改变并在编译过程中就能得到计算结果的表达式，显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式

一个对象或者表达水是不是常量表达式由它的数据类型和初始值共同决定

c++11新标准规定：允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式

若在constexpr声明中定义了一个指针，限定符constexpr仅对指针有效，对指针所指的对象无关

### 处理类型

typedef：定义类型别名

新标准规定了一种新的方法，使用别名声明来定义类型的别名：

```c++
using SI = Sales_time;
```

```c++
typedef char *pstring; // pstring 为类型 char* 的别名
const pstring cstr = 0; // cstr 是指向char的常量指针
const pstring *ps; // ps 是一个指针，他的对象是指向char的常量指针
const char * cst3 = 0; // cst3 是一个指向const char的指针
```

#### auto类型说明符

1. 使用引用其实就是使用引用的对象，当引用被用作初始值时，真正参与初始化的其实是引用对象的值，此时编译器以引用对象的类型作为auto的类型；
2. auto一般回忽略顶层const，保留底层const，如果需要推断出的auto类型是一个顶层const，则需要指出

```c++
const auto f = ci;
```

#### decltype类型指示符

选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，但不实际计算表达式的值：

```c++
decltype(f()) sum = x; // sum 的类型为函数f的返回值类型
```

### 自定义数据结构

struct关键字



## CHAPTER_3_字符串、向量和数组































































































































# END_FILE(LOADING_BOOK_2_PAGES_100)